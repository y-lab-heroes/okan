"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerialExecutorTimeoutError = exports.createSerialExecutor = void 0;
const events_1 = require("events");
function createSerialExecutor() {
    return new SerialExecutorImpl();
}
exports.createSerialExecutor = createSerialExecutor;
class SerialExecutorTimeoutError extends Error {
    constructor(key, timeout) {
        super();
        this.message = `execute:${key} was ${timeout} ms timeout`;
    }
}
exports.SerialExecutorTimeoutError = SerialExecutorTimeoutError;
class SerialExecutorImpl {
    constructor() {
        this.queue = [];
        this.isActive = false;
        this.count = 0;
        this.ee = new events_1.EventEmitter();
        this.queue = [];
        this.ee = new events_1.EventEmitter();
        this.isActive = false;
    }
    _activate() {
        this.isActive = true;
        process.nextTick(() => this._execute());
    }
    size() {
        return this.queue.length;
    }
    _generateUniqueKey() {
        this.count++;
        return `${this.count}-${new Date().getTime()}-${Math.random()}`;
    }
    async execute(_task, timeout = null) {
        let task = _task;
        const key = this._generateUniqueKey();
        if (timeout !== null) {
            const timeoutError = new SerialExecutorTimeoutError(key, timeout);
            task = () => Promise.race([
                _task(),
                new Promise((resolve, reject) => setTimeout(() => {
                    reject(timeoutError);
                }, timeout)),
            ]);
        }
        this.queue.push({
            task,
            key,
        });
        if (!this.isActive)
            this._activate();
        return new Promise((resolve, reject) => {
            this.ee.once(`executed:${key}`, (err, result) => {
                err ? reject(err) : resolve(result);
            });
        });
    }
    _dequeue() {
        return this.queue.shift();
    }
    async _execute() {
        const reg = this._dequeue();
        if (reg) {
            try {
                const result = await reg.task();
                this.ee.emit(`executed:${reg.key}`, null, result);
            }
            catch (e) {
                this.ee.emit(`executed:${reg.key}`, e, null);
            }
            finally {
                process.nextTick(() => this._execute());
            }
        }
        else {
            this.isActive = false;
        }
    }
}
//# sourceMappingURL=serial-executor.js.map